import { useReducer, useEffect, useContext, createContext, ReactNode, useState } from 'react';
import { GameState, XPGain, Quest, HealthActivity, HealthActivityType, Collectible, Season, ActivityLog, ChatMessage } from '../types/game';
import { playerReducer } from '../reducers/playerReducer';
import { questReducer } from '../reducers/questReducer';
import { healthReducer } from '../reducers/healthReducer';
import { collectiblesReducer } from '../reducers/collectiblesReducer';
import { generalReducer } from '../reducers/generalReducer';
import { ALL_ACHIEVEMENTS } from '../data/achievements';
import { DEFAULT_HEALTH_ACTIVITIES } from '../data/healthActivities';
import AIChatbotDialog from '../components/AIChatbotDialog';
import ManageHealthActivitiesDialog from '../components/ManageHealthActivitiesDialog';

import type { PlayerAction } from '../reducers/playerReducer';
import type { QuestAction } from '../reducers/questReducer';
import type { HealthAction } from '../reducers/healthReducer';
import type { CollectiblesAction } from '../reducers/collectiblesReducer';
import type { GeneralAction } from '../reducers/generalReducer';

// Główny reducer, który deleguje akcje do mniejszych reducerów
// Definicja wszystkich możliwych akcji w grze
type GameAction = PlayerAction | QuestAction | HealthAction | CollectiblesAction | GeneralAction;


const initialState: GameState = {
  player: {
    id: 'player_1',
    name: 'Hero',
    level: 1,
    xp: 0,
    xpToNextLevel: 100,
    skillPoints: 0,
    currentStreak: 0,
    longestStreak: 0,
    lastActiveDate: new Date()
  },
  healthActionTypes: [], // Initialize empty array that will be filled with DEFAULT_HEALTH_ACTIVITIES
  mainQuest: {
    title: 'Begin Your Journey',
    description: 'Complete your first quest to start building momentum',
    isActive: true
  },
  currentSeason: {
    id: 'season_1',
    title: 'Foundation Building',
    description: 'Establish core systems and routines',
    startDate: new Date(),
    endDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 dni od teraz
    progress: 0,
    goals: [
      'Complete 10 daily quests',
      'Collect your first rare item',
      'Maintain 7-day streak',
      'Unlock the collectibles system'
    ]
  },
  quests: [
    {
      id: crypto.randomUUID(),
      title: 'Set Up Your Workspace',
      description: 'Organize your desk and digital workspace for maximum productivity',
      type: 'main',
      xpReward: 50,
      priority: 'high',
      status: 'active',
      createdDate: new Date(),
      estimatedTime: 30,
      difficultyLevel: 2,
      energyRequired: 'medium',
      anxietyLevel: 'comfortable',
      tags: ['productivity', 'setup', 'environment']
    },
    {
      id: crypto.randomUUID(),
      title: 'Daily Reflection',
      description: 'Write 3 things you accomplished today and 1 thing you learned',
      type: 'daily',
      xpReward: 15,
      priority: 'medium',
      status: 'active',
      createdDate: new Date(),
      estimatedTime: 10,
      difficultyLevel: 1,
      energyRequired: 'low',
      anxietyLevel: 'comfortable',
      tags: ['reflection', 'growth', 'mindfulness']
    },
    {
      id: crypto.randomUUID(),
      title: 'Tackle That Dreaded Task',
      description: 'Pick one task you\'ve been avoiding and just start it (even for 5 minutes)',
      type: 'side',
      xpReward: 35,
      priority: 'high',
      status: 'active',
      createdDate: new Date(),
      estimatedTime: 15,
      difficultyLevel: 4,
      energyRequired: 'high',
      anxietyLevel: 'challenging',
      tags: ['anxiety', 'avoidance', 'breakthrough']
    }
  ],
  collectibles: [],
  healthBar: {
    current: 100,
    maximum: 100,
    lastUpdated: new Date()
  },
  settings: {
    soundEnabled: true,
    animationsEnabled: true,
    notificationsEnabled: false,
    theme: 'dark',
    dailyXPGoal: 100,
    maxActiveQuests: 5
  },
  statistics: {
    totalXPEarned: 0,
    totalQuestsCompleted: 0,
    longestStreak: 0,
    currentStreak: 0,
    averageTaskCompletionTime: 0,
    favoriteQuestTypes: [],
    collectiblesFound: 0,
    healthActivitiesLogged: 0
  },
  recentActivity: [],
  lastSaved: new Date(),
  customHealthActivities: [],
  unlockedAchievements: [],
  unlockedSkills: [],
  aiChatDefaultPrompt: '',
  aiChatHistory: [],
};

function gameReducer(state: GameState, action: GameAction): GameState {
  let updates: Partial<GameState> = {};

  switch (action.type) {
    case 'UPDATE_STREAK':
    case 'ADD_XP':
    case 'ACTIVATE_BONUS_XP':
    case 'SPEND_SKILL_POINTS':
    case 'ADD_HEALTH':
      updates = playerReducer(state, action as PlayerAction);
      break;
    case 'COMPLETE_QUEST':
    case 'ADD_QUEST':
    case 'SET_MAIN_QUEST':
    case 'SET_ACTIVE_QUEST':
      updates = questReducer(state, action as QuestAction);
      break;
    case 'UPDATE_HEALTH':
      updates = healthReducer(state, action as HealthAction);
      break;
    case 'ADD_COLLECTIBLE':
      updates = collectiblesReducer(state, action as CollectiblesAction);
      break;
    case 'LOAD_GAME_STATE':
    case 'UPDATE_SEASON_PROGRESS':
    case 'LOG_ACTIVITY':
    case 'UPDATE_SEASON':
    case 'ADD_HEALTH_ACTIVITY':
    case 'UPDATE_HEALTH_ACTIVITY':
    case 'REMOVE_HEALTH_ACTIVITY':
    case 'UNLOCK_ACHIEVEMENT':
    case 'UNLOCK_SKILL':
    case 'SET_AI_CHAT_PROMPT':
    case 'ADD_CHAT_MESSAGE':
    case 'CLEAR_CHAT_HISTORY':
      updates = generalReducer(state, action as GeneralAction);
      break;
    default:
      return state;
  }
  return {
    ...state,
    ...updates,
    lastSaved: new Date()
  };
}

interface GameContextType {
  state: GameState;
  actions: {
    completeQuest: (questId: string) => void;
    addXP: (xpGain: XPGain) => void;
    addQuest: (quest: Quest) => void;
    editQuest: (quest: Quest) => void;
    updateHealth: (change: number, activity?: HealthActivity) => void;
    setMainQuest: (title: string, description: string) => void;
    updateSeasonProgress: (progress: number) => void;
    addCollectible: (collectible: Collectible) => void;
    updateStreak: (date?: Date) => void;
    activateBonusXP: (multiplier: number, duration: number, reason: string) => void;
    updateSeason: (season: Season) => void;
    addHealthActivity: (activity: HealthActivity) => void;
    updateHealthActivity: (activity: HealthActivity) => void;
    removeHealthActivity: (activityId: string) => void;
    addHealthActionType: (activityType: HealthActivityType) => void;
    updateHealthActionType: (activityType: HealthActivityType) => void;
    removeHealthActionType: (activityTypeId: string) => void;
    logActivity: (activity: ActivityLog) => void;
    unlockAchievement: (achievementId: string) => void;
    unlockSkill: (skillId: string) => void;
    spendSkillPoints: (amount: number) => void;
    setActiveQuest: (questId: string | null) => void;
    addHealth: (amount: number) => void;
    setAIChatPrompt: (prompt: string) => void;
    openAIChat: (prompt?: string) => void;
    closeAIChat: () => void;
    addChatMessage: (message: ChatMessage) => void;
    clearChatHistory: () => void;
    openManageHealthActivitiesDialog: () => void;
    closeManageHealthActivitiesDialog: () => void;
  };
}

const GameContext = createContext<GameContextType | undefined>(undefined);

function GameProvider({ children }: { children: ReactNode }) {
  // Create a modified initial state with default health action types
  const initialStateWithHealthActions = {
    ...initialState,
    healthActionTypes: DEFAULT_HEALTH_ACTIVITIES
  };
  
  const [state, dispatch] = useReducer(gameReducer, initialStateWithHealthActions);
  
  // Dialog states
  const [isManageHealthActivitiesOpen, setManageHealthActivitiesOpen] = useState(false);

  useEffect(() => {
    dispatch({ type: 'UPDATE_STREAK', payload: { date: new Date() } });
  }, []);

  useEffect(() => {
    const savedState = localStorage.getItem('gameState');
    if (savedState) {
      try {
        const parsedState = JSON.parse(savedState);
        parsedState.currentSeason.startDate = new Date(parsedState.currentSeason.startDate);
        parsedState.currentSeason.endDate = new Date(parsedState.currentSeason.endDate);
        parsedState.healthBar.lastUpdated = new Date(parsedState.healthBar.lastUpdated);
        parsedState.lastSaved = new Date(parsedState.lastSaved);
        parsedState.player.lastActiveDate = new Date(parsedState.player.lastActiveDate);
        if (parsedState.bonusXPActive) {
          parsedState.bonusXPActive.expiresAt = new Date(parsedState.bonusXPActive.expiresAt);
        }
        parsedState.quests = parsedState.quests.map((q: any) => ({
          ...q,
          createdDate: new Date(q.createdDate),
          completedDate: q.completedDate ? new Date(q.completedDate) : undefined,
          deadline: q.deadline ? new Date(q.deadline) : undefined
        }));
        parsedState.collectibles = parsedState.collectibles?.map((c: any) => ({
          ...c,
          dateCollected: new Date(c.dateCollected)
        })) || [];
        parsedState.recentActivity = parsedState.recentActivity?.map((a: any) => ({
          ...a,
          timestamp: new Date(a.timestamp)
        })) || [];
        parsedState.statistics = parsedState.statistics || {
          totalXPEarned: 0,
          totalQuestsCompleted: 0,
          longestStreak: 0,
          currentStreak: 0,
          averageTaskCompletionTime: 0,
          favoriteQuestTypes: [],
          collectiblesFound: 0,
          healthActivitiesLogged: 0
        };
        parsedState.customHealthActivities = parsedState.customHealthActivities || [];
        parsedState.healthActionTypes = parsedState.healthActionTypes || [...initialStateWithHealthActions.healthActionTypes];
        parsedState.unlockedAchievements = parsedState.unlockedAchievements || [];
        parsedState.unlockedSkills = parsedState.unlockedSkills || [];
        parsedState.aiChatDefaultPrompt = parsedState.aiChatDefaultPrompt || '';
        if (parsedState.aiChatHistory && Array.isArray(parsedState.aiChatHistory)) {
          const uniqueChatHistory: ChatMessage[] = [];
          const seenIds = new Set<string>();
          parsedState.aiChatHistory.forEach((msg: ChatMessage) => {
            if (msg.id && typeof msg.id === 'string' && !seenIds.has(msg.id)) {
              uniqueChatHistory.push(msg);
              seenIds.add(msg.id);
            } else if (msg.id) {
              console.warn("Duplicate or invalid chat message ID found in localStorage, skipping:", msg.id);
            }
          });
          parsedState.aiChatHistory = uniqueChatHistory;
        } else {
          parsedState.aiChatHistory = [];
        }
        dispatch({ type: 'LOAD_GAME_STATE', payload: parsedState });
      } catch (error) {
        console.error('Failed to load game state:', error);
      }
    }
  }, []);

  useEffect(() => {
    localStorage.setItem('gameState', JSON.stringify(state));
  }, [state]);

  useEffect(() => {
    ALL_ACHIEVEMENTS.forEach((achievement) => {
      if (
        achievement.criteria(state) && !state.unlockedAchievements.includes(achievement.id)
      ) {
        dispatch({ type: 'UNLOCK_ACHIEVEMENT', payload: achievement.id });
        dispatch({
          type: 'LOG_ACTIVITY',
          payload: {
            id: crypto.randomUUID(),
            type: 'achievement_unlocked',
            description: `Achievement unlocked: "${achievement.name}"`,
            timestamp: new Date(),
          }
        });
      }
    });
  }, [state.player.level, state.statistics.totalQuestsCompleted, state.player.longestStreak, state.collectibles.length, state.statistics.healthActivitiesLogged, state.unlockedAchievements]);

  const actions = {
    editQuest: (quest: Quest) => dispatch({ type: 'EDIT_QUEST', payload: quest }),
    completeQuest: (questId: string) => dispatch({ type: 'COMPLETE_QUEST', payload: questId }),
    addXP: (xpGain: XPGain) => dispatch({ type: 'ADD_XP', payload: xpGain }),
    addQuest: (quest: Quest) => dispatch({ type: 'ADD_QUEST', payload: quest }),
    updateHealth: (change: number, activity?: HealthActivity) => dispatch({ type: 'UPDATE_HEALTH', payload: { change, activity } }),
    setMainQuest: (title: string, description: string) => dispatch({ type: 'SET_MAIN_QUEST', payload: { title, description } }),
    updateSeasonProgress: (progress: number) => dispatch({ type: 'UPDATE_SEASON_PROGRESS', payload: progress }),
    addCollectible: (collectible: Collectible) => dispatch({ type: 'ADD_COLLECTIBLE', payload: collectible }),
    updateStreak: (date = new Date()) => dispatch({ type: 'UPDATE_STREAK', payload: { date } }),
    activateBonusXP: (multiplier: number, duration: number, reason: string) => dispatch({ type: 'ACTIVATE_BONUS_XP', payload: { multiplier, duration, reason } }),
    updateSeason: (season: Season) => dispatch({ type: 'UPDATE_SEASON', payload: season }),
    addHealthActivity: (activity: HealthActivity) => dispatch({ type: 'ADD_HEALTH_ACTIVITY', payload: activity }),
    updateHealthActivity: (activity: HealthActivity) => dispatch({ type: 'UPDATE_HEALTH_ACTIVITY', payload: activity }),
    removeHealthActivity: (activityId: string) => dispatch({ type: 'REMOVE_HEALTH_ACTIVITY', payload: activityId }),
    addHealthActionType: (activityType: HealthActivityType) => dispatch({ type: 'ADD_HEALTH_ACTION_TYPE', payload: activityType }),
    updateHealthActionType: (activityType: HealthActivityType) => dispatch({ type: 'UPDATE_HEALTH_ACTION_TYPE', payload: activityType }),
    removeHealthActionType: (activityTypeId: string) => dispatch({ type: 'REMOVE_HEALTH_ACTION_TYPE', payload: activityTypeId }),
    logActivity: (activity: ActivityLog) => dispatch({ type: 'LOG_ACTIVITY', payload: activity }),
    unlockAchievement: (achievementId: string) => dispatch({ type: 'UNLOCK_ACHIEVEMENT', payload: achievementId }),
    unlockSkill: (skillId: string) => dispatch({ type: 'UNLOCK_SKILL', payload: skillId }),
    spendSkillPoints: (amount: number) => dispatch({ type: 'SPEND_SKILL_POINTS', payload: { amount } }),
    setActiveQuest: (questId: string | null) => dispatch({ type: 'SET_ACTIVE_QUEST', payload: questId }),
    addHealth: (amount: number) => dispatch({ type: 'ADD_HEALTH', payload: amount }),
    setAIChatPrompt: (prompt: string) => { dispatch({ type: 'SET_AI_CHAT_PROMPT', payload: prompt }); },
    openAIChat: (prompt?: string) => { if (prompt) { dispatch({ type: 'SET_AI_CHAT_PROMPT', payload: prompt }); } },
    closeAIChat: () => {
      dispatch({ type: 'SET_AI_CHAT_PROMPT', payload: '' });
      dispatch({ type: 'CLEAR_CHAT_HISTORY' });
    },
    addChatMessage: (message: ChatMessage) => dispatch({ type: 'ADD_CHAT_MESSAGE', payload: message }),
    clearChatHistory: () => dispatch({ type: 'CLEAR_CHAT_HISTORY' }),
    openManageHealthActivitiesDialog: () => setManageHealthActivitiesOpen(true),
    closeManageHealthActivitiesDialog: () => setManageHealthActivitiesOpen(false),
  };

  return (
    <GameContext.Provider value={{ state, actions }}>
      {children}
      <AIChatbotDialog />
      <ManageHealthActivitiesDialog 
        open={isManageHealthActivitiesOpen} 
        onOpenChange={setManageHealthActivitiesOpen} 
      />
    </GameContext.Provider>
  );
}

function useGame() {
  const context = useContext(GameContext);
  if (context === undefined) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return context;
}

export { useGame, GameProvider };
